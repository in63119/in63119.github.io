---
title: 업그레이더블 컨트랙트와 Delegate call
author: IN
date: 2022-11-7 23:32:00 +0800
categories: [Blogging, Blockchain]
tags: [Contract, Upgradable, Delegate call]
pin: true
---

이제는 기본적으로 구성해야 하는 업그레이더블 컨트랙트와 로직과 스토리지를 구분하는 Delegate call에 대해 알아보자.
<br />
<br />

## Upgredable Contract

업그레이더블 컨트랙트는 말 그대로 **업그레이드가 가능한** 컨트랙트이다.
<br />
사실 블록체인 안에 스마크 컨트랙트는 **절대로** 변경할 수 없다. 그런데, 이렇게 생각해보자.
<br />
만약 어떤 서비스를 제공하는데 당연히 버전 업이 필요할 때가 있다. 이럴 땐 수정 불가한 컨트랙트를 어떻게 수정할까?
<br />
해답은 하나의 컨트랙트를 Proxy 컨트랙트와 로직 컨트랙트로 분리하는 것이다.

<img src="https://user-images.githubusercontent.com/65399118/200363795-89b8e41f-b514-43e3-a979-d44563bbbaa0.png" alt="diablo" width="600"/>

<br />

이미지를 보면 유저가 업그레이더블 프록시 컨트랙트를 호출하면 업그레이더블 프록시 컨트랙트는 기능 로직이 있는 로직 컨트랙트를 호출한다.

<br />

여기서 로직 컨트랙트는 언제든지 쓰다버리는(?) 컨트랙트가 되는 것이고, 새로운 로직 컨트랙트를 만들게 되면
<br />

업그레이더블 프록시 컨트랙트에서 해당 컨트랙트의 주소를 입력하여 다시 호출하게끔 만드는 것이다.

<br />
<br />

## Delegate call

이 떄, 로직 컨트랙트에서 사용된 함수의 상태변경을 업그레이더블 프록시 컨트랙트에서 진행하고 싶다면?

<br />

바로, Delegate call을 사용하는 것이다.

<br />

Delegate call은 **다른 컨트랙트를 호출할 때, 코드는 호출당한 컨트랙트 것을 사용하되, 실행은 호출한 컨트랙트에서 실행하는 요상한(?) 녀석이다.**

> 호출한 컨트랙트 - "(호출당한 컨트랙트)야 가서 빵좀 사와. 네 돈으로."

즉, 양아치(?)다.

<br />
<br />

이렇게 Delegate call과 Proxy Contract 덕분에 기능은 다른 컨트랙트를 사용하고, 스토리지는 내(?)것을 쓰기 때문에

<br />

기능 컨트랙트를 다른것으로 갈면서 업그레이드가 가능한 것이다.

<br />
